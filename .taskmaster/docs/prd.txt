Project: Dreamworld â€” State Of The Aart Implementation Spec

Core Directive:
Favor procedural geometry, mathematical lighting, and seamless DOM integration over heavy textures and generic game-engine bloat. Tolerate zero bugs, glitches errors, warnings or other performance impediments that aren't absolutely necessary for our SOTA quality.

*** AGENT OVERRIDE: CONTINUOUS REFINEMENT ***
Do not stop at "bug-free and functional" 
1. Critique: Is the interaction tactile? Does it feel heavy?
2. Optimize: Minimal allocations inside the render loop. Uniform updates only.
3. Polish: Push the limits of WebGPU shaders (4x MSAA, High-Poly Spheres) until frame budgets are hit.

1. The Vision
A "Sandwich" experience where the 3D world exists physically between HTML layers. It is not a background; it is a participant in the interface.
- Aesthetic Goal: "Dreamworld" Smooth, matte surfaces, soft shadows, and physical weight. Prefer geometry and light over fallback textures. Smooth movements with effortless navigation.
- Interaction Philosophy: The 3D object is a physical presence that pushes 2D UI elements away and reacts to the cursor like a magnetic field.

2. Architecture (The "Sandwich" Stack)
- Layer 0 (Back): HTML/CSS Background (Time-of-Day Gradient).
- Layer 1 (Middle): WebGPU Canvas (Transparent, Alpha-PreMultiplied).
- Layer 2 (Front): Floating UI Elements (HTML/CSS) that react to Layer 1.

- Engine Core: Custom Rust/WGPU (v24+).
  - Architecture: Forward Renderer.
  - Optimization Strategy: "Uniform-Driven Motion." Never recreate mesh buffers on frame updates. Use Uniform Buffers (`BlobUniform`) to modify vertex positions in the shader.
- Data Sync: `get_blob_screen_position` (Rust) -> `requestAnimationFrame` (JS) -> CSS Transforms.

3. The "Immersive Axes" (Feature Goals)

Axis I: TIME (Atmospheric Sync)
- Goal: The digital world reflects the user's physical reality.
- Mechanism: 
  - CSS Background Gradient syncs with local time (Dawn/Day/Dusk/Night).
  - WGPU Lighting (Hemispheric Ambient) syncs exactly with the CSS gradient colors.
  - "Sky Color" and "Ground Color" are passed as Uniforms to the PBR Shader.

Axis II: AUDIO VISUALIZATION (Deforming Space)
- Goal: Sound is not a bar graph; it is a physical force.
- Mechanism:
  - Vertex Shader Deformation: The "Grid" floor ripples using `sin/cos` waves driven by `audio.intensity` uniforms.
  - SOTA Optimization: 100% GPU-side animation. No CPU vertex manipulation.

Axis III: THE PHYSICAL INTERFACE (3D-to-2D Collision)
- Goal: Break the fourth wall.
- Mechanism: 
  - Project the 3D "Blob" position to 2D Screen Space (NDC -> Pixel Coordinates) inside Rust.
  - JS reads this coordinate and applies CSS `transform: translate()` to "push" HTML buttons away when the Blob gets close.
- Physics: "Physics-Lite." Use algebraic distance checks (Circle-Rectangle collision) in JS for UI repulsion, avoiding heavy WASM physics engines for simple UI effects.

Axis IV: CLAY LIGHTING (Procedural PBR)
- Goal: Tangible realism without texture downloads.
- Mechanism:
  - "Clay PBR": High Roughness, Low Metallic, High Ambient Occlusion.
  - Lighting: 
    1. Direct: Point Light (Cursor/Sun).
    2. Indirect: Hemispheric Ambient (Gradient based on Normal.y).
    3. Emissive: Audio intensity maps to material emission (Glow).

4. Technical Specifications (SOTA Standards)

Graphics (WGPU/Rust)
- MSAA: 4x Multisample Anti-Aliasing (Critical for the "smooth clay" look).
- Color Space: Hardware sRGB decoding.
- Asset Loading: Low-Level `gltf::Gltf::from_slice`. Bypass high-level validation to support browser-native image decoding (WebP) via `createImageBitmap`.
- Resize Strategy: `devicePixelContentBoxSize` for 1:1 physical pixel mapping on Retina displays.

Performance Guardrails
- Battery Saver: Use `IntersectionObserver` and `document.hidden` to hard-stop the Render Loop when not visible.
- Texture Fallback: If textures fail or are disabled, render pure 1x1 white pixel (Pure Clay Mode).
- Input Stability: Use Manual Delta Calculation (`clientX - lastX`) for Orbit controls to fix iOS/Touch jitter.

5. Scalability Strategy
- Tier 1 (Low Power): 1x MSAA, Standard Resolution.
- Tier 2 (High Power): 4x MSAA, 1:1 Device Pixel Ratio.
- Dynamic Adjustment: Monitor frame time in JS. If FPS < 45, degrade DPR (Dynamic Resolution Scaling).

6. Current Roadmap
Phase 1: Stabilization (Current)
- Fix WGPU v24 `limits` and `cache` structs.
- Implement `BlobUniform` to stop mesh recreation lag.
- Finalize `load_model_from_bytes` using the low-level parser fix.

Phase 2: Integration
- Connect JS Date() to Rust `set_environment_light`.
- Connect Rust `get_blob_screen_position` to HTML UI repulsion logic.

Phase 3: Polish
- Tune the "Hemispheric" light gradient to perfectly match the CSS background.
- Add "Soft Shadows" (simulated via darkened ground ambient color).