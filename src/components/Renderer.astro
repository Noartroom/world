---
// model_renderer/src/components/Renderer.astro
const CANVAS_ID = "webgpu-canvas";  // modernart1-sculpt-1, IMAGE3D-1, dezimiertt-glb-03
const { modelPath = "/models/modernart1-sculpt-1.glb" } = Astro.props;
---

<div 
  class="renderer-container" 
  id="renderer-container-id"
  data-canvas-id={CANVAS_ID}
  data-model-path={modelPath}
  aria-label="Interactive 3D Model Viewer" 
  role="application">
  <div 
    id="loader" 
    class="loader"
  >INITIALIZING GPU...</div>
  <div 
    id="debug-overlay" 
    style="position: absolute; top: 10px; left: 10px; color: #0f0; background: rgba(0,0,0,0.7); padding: 10px; pointer-events: none; font-family: monospace; z-index: 9999;">
      Waiting for audio data...
  </div>
  
  <canvas id={CANVAS_ID} tabindex="0" aria-label="3D Canvas"></canvas>
  <div class="css-light-overlay"></div>
</div>

<script>
  // @ts-ignore
  import init, { startRenderer } from '/pkg/model_renderer.js?v=gpu_fix_6';
  import { theme, activeModel, onSet, isDynamicLightActive, isBlobActive } from '../lib/stores/sceneStore';
  import { getAudioData, getStereoData, getComprehensiveAudioAnalysis } from '../lib/stores/audioStore';

    // DOM Elemente
  const container = document.getElementById('renderer-container-id');
  const CANVAS_ID = container?.dataset.canvasId;
  const modelPath = container?.dataset.modelPath;
  // --- Global Scope (f√ºr Cleanup notwendig) ---
  let state: any = null;
  let rafId: number | null = null;
  let resizeObserver: ResizeObserver | null = null;
  let intersectionObserver: IntersectionObserver | null = null;
  let isVisible = true;
  let themeUnsub: (() => void) | null = null;
  let lightUnsub: (() => void) | null = null;
  let blobUnsub: (() => void) | null = null;
  let modelUnsub: (() => void) | null = null;
  let isLoadingModel = false; // Prevent concurrent model loads

  // Performance Monitoring (SOTA Guardrails)
  let lastFrameTime = performance.now();
  let frameTimer = 0;
  let frameCount = 0;
  let currentDpr = typeof window !== 'undefined' ? (window.devicePixelRatio || 1) : 1;
  let targetDpr = currentDpr;

  // DOM Elemente
  const canvas: HTMLCanvasElement | null = CANVAS_ID ? document.getElementById(CANVAS_ID) as HTMLCanvasElement : null;
  const loader = document.getElementById('loader');

  // Input State
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;
  let isDraggingBlob = false;
  let lastCanvasX = -1; // -1 indicates not yet set
  let lastCanvasY = -1;
  let hasSpawnedSinceActive = false; // Prevents re-spawning on every mouse move
  
  // Performance: Cache DOM queries and computed values
  let cachedCanvasRect: DOMRect | null = null;
  let lastCachedRectTime = 0;
  const RECT_CACHE_DURATION = 100; // Cache rect for 100ms
  let cachedTheme = null;
  let cachedOverlayGradient = null;

  // --- SOTA Render Loop ---
  function renderLoop(timestamp: number) {
    // 0. Safety: Stoppen, wenn Canvas nicht mehr im DOM ist (Astro View Transition)
    if (!canvas || !canvas.isConnected) {
        cleanup();
        return;
    }

    // 1. Battery Saver: Pause, wenn Tab im Hintergrund oder Canvas off-screen
    if (!isVisible || document.hidden) {
      rafId = requestAnimationFrame(renderLoop);
      return;
    }

    // 2. Performance Guardrails: Monitor Frame Time
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // Einfacher FPS Counter √ºber 1 Sekunde
    frameTimer += delta;
    frameCount++;
    
    if (frameTimer >= 1000) {
      const fps = frameCount;
      // console.log(`FPS: ${fps}, DPR: ${currentDpr.toFixed(2)}`);
      
      // Dynamic Resolution Scaling (Tiered)
      // Wenn FPS unter 45 fallen, reduziere Aufl√∂sung (min 0.5)
      if (fps < 45 && currentDpr > 0.5) {
         targetDpr = Math.max(0.5, currentDpr - 0.25);
         triggerResize(); // Trigger resize with new DPR
      }
      // Wenn FPS stabil bei 60 sind, versuche Qualit√§t zu erh√∂hen (bis native DPR)
      else if (fps >= 58 && currentDpr < (window.devicePixelRatio || 1)) {
         targetDpr = Math.min(window.devicePixelRatio || 1, currentDpr + 0.1);
         triggerResize();
      }
      
      frameTimer = 0;
      frameCount = 0;
    }

    if (state) {
      try {
        // Pass audio data to WASM
        try {
            const audioData = getAudioData();
            const stereo = getStereoData();

            if (audioData && audioData.length > 0 && audioData instanceof Uint8Array) {
                const sum = audioData.reduce((a, b) => a + b, 0);
                const avg = sum / audioData.length;
                
                // avg is roughly 0-100, max 255.
                const intensity = Math.min(avg / 80.0, 1.0); // Increased sensitivity

                // Audio intensity is kept for visual effects only (no position changes)
                // Light position is purely user-controlled via drag

                // Enhanced Audio Analysis & Debug Output
                const debugEl = document.getElementById('debug-overlay');
                if (debugEl && frameCount % 10 === 0) {
                    // Get comprehensive audio analysis
                    const audioAnalysis = getComprehensiveAudioAnalysis();
                    const { frequencyBands, rmsEnergy, spatial, spectralCentroid, spectralRolloff, peakFrequency, zeroCrossingRate } = audioAnalysis;
                    
                    // Calculate balance for display
                    const totalVol = (stereo.left + stereo.right) || 1;
                    const balance = (stereo.right - stereo.left) / totalVol;
                    
                    debugEl.innerHTML = `
                        <div style="font-size: 10px; line-height: 1.4;">
                            <strong>AUDIO SIGNAL ANALYSIS</strong><br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Basic:</strong><br>
                            Intensity: ${intensity.toFixed(3)} | Avg: ${avg.toFixed(1)}<br>
                            L: ${stereo.left.toFixed(1)} | R: ${stereo.right.toFixed(1)}<br>
                            Balance: ${balance.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Frequency Bands:</strong><br>
                            Bass: ${frequencyBands.bass.toFixed(1)} | Mid: ${frequencyBands.mid.toFixed(1)} | Treble: ${frequencyBands.treble.toFixed(1)}<br>
                            <strong>RMS Energy:</strong><br>
                            B: ${rmsEnergy.bass.toFixed(3)} | M: ${rmsEnergy.mid.toFixed(3)} | T: ${rmsEnergy.treble.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Spectral:</strong><br>
                            Centroid: ${spectralCentroid.toFixed(0)} Hz<br>
                            Rolloff: ${spectralRolloff.toFixed(0)} Hz<br>
                            Peak: ${peakFrequency.toFixed(0)} Hz<br>
                            ZCR: ${zeroCrossingRate.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Spatial:</strong><br>
                            Width: ${spatial.stereoWidth.toFixed(3)}<br>
                            Phase: ${spatial.phaseDifference.toFixed(3)}<br>
                            Separation: ${spatial.channelSeparation.toFixed(3)}<br>
                            Azimuth: ${spatial.azimuth.toFixed(3)}
                        </div>
                    `;
                    debugEl.style.color = sum > 0 ? '#0f0' : '#f00';
                    
                    if (sum > 0) {
                        const borderAlpha = 0.3 + (intensity * 0.7);
                        const glowSize = 5 + (intensity * 20);
                        debugEl.style.border = `2px solid rgba(0, 255, 0, ${borderAlpha})`;
                        debugEl.style.boxShadow = `0 0 ${glowSize}px rgba(0, 255, 0, ${borderAlpha})`;
                    } else {
                        debugEl.style.border = 'none';
                        debugEl.style.boxShadow = 'none';
                    }
                }

                state.updateAudioData(audioData);

                // CSS overlay high emittance effect removed - only 3D cursor-directed lighting remains
            }
        } catch (audioErr) {
             console.warn("Audio Update Error (Non-fatal):", audioErr);
        }

        state.render();
      } catch (e) {
        console.error("Render Crash:", e);
        cleanup(); // Notfall-Cleanup
        return;
      }
    }
    rafId = requestAnimationFrame(renderLoop);
  }

  // --- Initialization ---
  async function start() {
    if (!canvas) return;

    try {
      await init();
      state = await startRenderer(canvas);
      
      // 1. Theme Sync - Initialize lighting based on current theme
      if (theme) {
        const initialTheme = theme.get();
        state.setTheme(initialTheme === 'dark');
        themeUnsub = onSet(theme, ({ newValue }) => {
            if (state) state.setTheme(newValue === 'dark');
        });
      }

      // 1.5 Dynamic Light Sync
      // Cursor-directed 3D lighting is enabled by default (controlled by isDynamicLightActive)
      // Initialize light position to center
      document.documentElement.style.setProperty('--light-x', '50vw');
      document.documentElement.style.setProperty('--light-y', '50vh');
      
      // Handle cursor-directed 3D lighting toggle
      // When disabled, cursor light should disappear (not stay at last position)
      lightUnsub = onSet(isDynamicLightActive, ({ newValue }) => {
         // Update cursor light active state in Rust
         if (state && state.setCursorLightActive) {
             state.setCursorLightActive(newValue);
         }
      });
      
      // Initialize cursor light state (enabled by default)
      if (state && state.setCursorLightActive) {
          const initialDynamicLight = isDynamicLightActive.get();
          state.setCursorLightActive(initialDynamicLight);
      }

      // Handle light blob spawning/despawning ONLY (separate from CSS lighting)
      blobUnsub = onSet(isBlobActive, ({ newValue }) => {
         if (!newValue && state) {
             // Despawn blob
             if (state.despawnBlob) {
                 state.despawnBlob();
             }
             isDraggingBlob = false;
             hasSpawnedSinceActive = false; // Reset spawn flag
         } else if (newValue) {
            // On activation, set flag to spawn on next mouse move
            hasSpawnedSinceActive = false;
         }
      });

      // 1.6 Model Switching
      let isInitialLoad = true; // Track if we're doing the initial load
      let currentLoadedModel: string | null = null; // Track currently loaded model
      
      const loadModel = async (modelType: string) => {
        // Prevent concurrent loads
        if (isLoadingModel) {
          console.log(`Model load already in progress, skipping ${modelType}`);
          return;
        }

        // Skip if already loaded
        if (currentLoadedModel === modelType && !isInitialLoad) {
          console.log(`Model ${modelType} already loaded, skipping`);
          return;
        }

        // Ensure state is ready
        if (!state) {
          console.error('Cannot load model: renderer state not ready');
          return;
        }

        const modelPath = modelType === 'dark'
          ? '/models/dezimiertt-glb-03.glb'
          : '/models/modernart1-sculpt-1.glb';
        
        isLoadingModel = true;
        
        try {
          if (loader) {
            loader.classList.remove('hidden');
            loader.textContent = `LOADING ${modelType.toUpperCase()} MODEL...`;
          }
          
          const response = await fetch(modelPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const bytes = new Uint8Array(await response.arrayBuffer());
          
          // Small delay to ensure renderer is ready (fixes first-click issue)
          if (isInitialLoad) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          state.loadModelFromBytes(bytes);
          
          // Wait a bit for the model to be processed
          await new Promise(resolve => setTimeout(resolve, 50));
          
          currentLoadedModel = modelType; // Track what we loaded
          
          if (loader) {
            loader.classList.add('hidden');
          }
          console.log(`Model switched to: ${modelType}`);
        } catch (e) {
          console.error(`Failed to load model ${modelType}:`, e);
          if (loader) {
            loader.textContent = `ERROR LOADING ${modelType.toUpperCase()}`;
            // Auto-hide error after 3 seconds
            setTimeout(() => {
              if (loader) loader.classList.add('hidden');
            }, 3000);
          }
        } finally {
          isLoadingModel = false;
          if (isInitialLoad) {
            isInitialLoad = false;
          }
        }
      };

      // Load initial model (wait for it to complete before setting up subscription)
      const initialModel = activeModel.get();
      await loadModel(initialModel);

      // Subscribe to model changes (only after initial load is complete)
      modelUnsub = onSet(activeModel, ({ newValue }) => {
        // Skip if this is the initial value being set or if already loading
        if (isInitialLoad || isLoadingModel) {
          return;
        }
        
        // Only load if state is ready and value actually changed
        if (state && newValue !== currentLoadedModel) {
          loadModel(newValue);
        }
      });

      // 3. Systeme starten
      setupObservers();
      setupInput();
      
      // 4. Initial Resize erzwingen (Verhindert "Mini-Canvas" Blitz)
      triggerInitialResize();

      rafId = requestAnimationFrame(renderLoop);

    } catch (e: any) {
      console.group("üî¥ SOTA Renderer Error Log");
      console.error("Initialization failed. Details below:");
      if (e.stack) console.error("Stack:", e.stack);
      
      if (loader) loader.textContent = "GPU ERROR: " + e; // Zeige Fehler im UI an
      // Ensure we kill any zombie loops
      cleanup();
    }
  }

  function triggerResize() {
      if (!container || !canvas) return;
      // Manuelles Update, respektiert targetDpr
      currentDpr = targetDpr;
      const rect = container.getBoundingClientRect();
      // Invalidate cached canvas rect when resizing
      cachedCanvasRect = null;
      const width = Math.max(1, Math.floor(rect.width * currentDpr));
      const height = Math.max(1, Math.floor(rect.height * currentDpr));
      
      if (state && canvas && width > 0 && height > 0) {
          canvas.width = width;
          canvas.height = height;
          state.resize(width, height);
      }
  }

  function triggerInitialResize() {
      triggerResize();
  }

  // --- Observers (Resize & Visibility) ---
  function setupObservers() {
    // Resize Observer
    resizeObserver = new ResizeObserver(entries => {
      // Bei Container-Gr√∂√üen√§nderung (z.B. Fenstergr√∂√üe) immer neu berechnen
      triggerResize();
    });
    if (container) resizeObserver.observe(container);

    // Intersection Observer (Pausiert Render Loop wenn unsichtbar)
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
      });
    }, { threshold: 0 });
    if (canvas) intersectionObserver.observe(canvas);
  }

  // --- Input Handling (Pointer Events) ---
  function setupInput() {
    if (!container || !canvas) return;
    
    let blobClickTimeout: ReturnType<typeof setTimeout> | null = null;

    container.addEventListener('pointerdown', (e: PointerEvent) => {
      if (!state) return;

      const blobActive = isBlobActive.get();
      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Priority: 1. Start dragging blob
      if (blobActive && state.startDragBlob && state.startDragBlob(x, y, rect.width, rect.height)) {
        isDraggingBlob = true;
        isDragging = false; // Prevent camera drag
        e.preventDefault();
        e.stopPropagation();
        container.setPointerCapture(e.pointerId);
        container.style.cursor = 'grabbing';
      }
      // Priority: 2. Start dragging camera
      else {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        container.style.cursor = 'grabbing';
        container.setPointerCapture(e.pointerId);
      }
    });

    window.addEventListener('pointerup', (e: PointerEvent) => {
      if (isDraggingBlob && state && state.stopDragBlob) {
        state.stopDragBlob();
        isDraggingBlob = false;
      }
      if (isDragging) {
        isDragging = false;
      }
      if (container) {
        container.style.cursor = 'grab';
        if (container.hasPointerCapture(e.pointerId)) {
          container.releasePointerCapture(e.pointerId);
        }
      }
    });

    container.addEventListener('pointermove', (e: PointerEvent) => {
      if (!state || !canvas) return;

      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;

      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      lastCanvasX = x;
      lastCanvasY = y;

      if (isDragging && !isDraggingBlob) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        state.update_camera(deltaX * 1.0, deltaY * 1.0, 0);
        lastX = e.clientX;
        lastY = e.clientY;
      }

      // Spawn blob on first mouse move after activation
      if (isBlobActive.get() && !hasSpawnedSinceActive && state.spawnBlob) {
        state.spawnBlob(x, y, rect.width, rect.height);
        hasSpawnedSinceActive = true;
      }

      const dynamicLightEnabled = isDynamicLightActive.get();
      if (dynamicLightEnabled || isDraggingBlob) {
        state.update(x, y, rect.width, rect.height);
      }

      if (isBlobActive.get() && !isDraggingBlob && !isDragging) {
        if (state.isHoveringBlob && state.isHoveringBlob(x, y, rect.width, rect.height)) {
          container.style.cursor = 'grab';
        } else {
          container.style.cursor = 'default';
        }
      } else if (isDraggingBlob) {
        container.style.cursor = 'grabbing';
      }
    });

    container.addEventListener('wheel', (e: WheelEvent) => {
      if (state) {
        e.preventDefault();
        if (isBlobActive.get() && isDraggingBlob && state.updateBlobY) {
          state.updateBlobY(e.deltaY);
        } else {
          state.update_camera(0, 0, e.deltaY * 0.5);
        }
      }
    }, { passive: false });
  }

  // --- Cleanup ---
  function cleanup() {
    if (rafId) cancelAnimationFrame(rafId);
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (themeUnsub) themeUnsub();
    if (lightUnsub) lightUnsub();
    if (modelUnsub) modelUnsub();
    
    if (state && state.free) state.free();
    state = null;
  }

  start();

  // Astro Lifecycle Support
  document.addEventListener('astro:before-swap', cleanup);
</script>

<style>
.renderer-container {
  position: fixed;
  inset: 0;
  z-index: -1;
  background: transparent;
  cursor: grab;
  overflow: hidden;
  pointer-events: auto; /* clickable container for camera */
  /* Mobile UX: Verhindert Textauswahl beim Drehen */
  user-select: none; 
  -webkit-user-select: none;
  
  /* SOTA FIX: Verhindert Page-Scroll beim Draggen des Overlays */
  touch-action: none; 
}

#webgpu-canvas {
  display: block;
  width: 100%;
  height: 100%;
  outline: none;
}

.loader {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: #666;
  font-family: monospace;
  font-size: 12px;
  letter-spacing: 2px;
  transition: opacity 0.5s ease;
  pointer-events: none; /* clicks go through */
  z-index: 10;
}
.loader.hidden { opacity: 0; }

.css-light-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none; /* clicks go through */
  opacity: var(--light-opacity, 0);
  transition: opacity 0.1s ease;
  /* Theme-based gradient: cool white for dark theme */
  background: radial-gradient(
    circle 800px at var(--light-x, 50%) var(--light-y, 50%),
    rgba(240, 245, 255, 0.6) 0%,
    rgba(200, 220, 255, 0.2) 40%,
    rgba(0, 0, 0, 0.0) 70%
  );
  mix-blend-mode: screen;
  z-index: 2; /* Ensure it's above the canvas */
}
</style>